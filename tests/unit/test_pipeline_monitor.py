from typing import Iterable
import unittest
from mlops.azureml.pipeline_monitor import PipelineMonitor
from unittest.mock import patch, PropertyMock, MagicMock
from unittest import mock
import datetime

class MockWorkspace:
    def __init__(self, id, resource_group):
        self.id = id
        self.resource_group = resource_group
        pass

# objects generated by azure classes/functions are like this
object_1 = MockWorkspace(id='fake_id_1', resource_group='fake_resource_group_from_fake_id_1')
object_2 = MockWorkspace(id='fake_id_2', resource_group='fake_resource_group_from_fake_id_2')
resource_dict = {'fake_id_1': {'name': ['fake_resource_group_from_fake_id_1'], 'workspaces': [object_1]},
                 'fake_id_2': {'name': ['fake_resource_group_from_fake_id_2'], 'workspaces': [object_2]}}


class MockAzureWorkspaceClass:
    def __init__(self):
        pass

    @property
    def resources_dict(self):
        return resource_dict

class MockRun:
    def __init__(self, id, resource_group, step_name=None) -> None:
        self.id = id
        self.name = f'fake_run_{id}'
        self.resource_group = resource_group
        self.step_name=step_name
        pass

    def get_details(self):
        return {'status': 'Completed',
                'startTimeUtc': datetime.datetime.today().strftime("%Y-%m-%d %H:%M:%D"),}

    def get_steps(self): # he creates a generator here instead of a list, but just for testing purposes
                         # we will use a list
        return [MockRun(self.id, self.resource_group,step_name='fake_step_1'),
                MockRun(self.id, self.resource_group,step_name='fake_step_2')]

class MockExperiment:

    def __init__(self, ws: MockWorkspace) -> None:
        self.ws = ws
        self.name = f'fake_run_{ws.id}'
        pass

    @staticmethod
    def list(ws: MockWorkspace):
        return [MockExperiment(ws)]

    def get_runs(self):
        return [MockRun(self.ws.id, self.ws.resource_group)]



class Test_PipelineMonitor(unittest.TestCase):


    """
    after mocking and simulating the azure objects
    we test if our class can read/interact with them
    if any error is found, it means that there's a problem
    in the "pipelinemonitor"
    """

    def setUp(self) -> None:
        self.class_test = PipelineMonitor()

    @mock.patch('azureml.core.Experiment.list', autospec=True, side_effect=MockExperiment.list)
    @patch.object(PipelineMonitor, 'azure_resource_obj', new_callable=PropertyMock, return_value=MockAzureWorkspaceClass())
    def test_declare_class(self, mock_azure_resource_obj, mock_experiment):
        workspaces = list(self.class_test._get_workspaces())

        self.assertTrue(all(isinstance(i, MockWorkspace) for i in workspaces))

        # check if it can read the experiments
        result = self.class_test._get_experiments_map()
        self.assertEqual(len(list(result)), len(workspaces))

        # check if can filter the experiment
        result = list(self.class_test._get_specific_experiment(name='fake_run_fake_id_1'))
        self.assertEqual(result[0].name, 'fake_run_fake_id_1')
        result = list(self.class_test._get_specific_experiment(name='fake_run_fake_id_2'))
        self.assertEqual(result[0].name, 'fake_run_fake_id_2')

        # check if from the experiments it can generate the runs
        result = self.class_test._wrapper_experiments_runs()
        self.assertTrue(all(isinstance(i, MockRun) for i in result))

        # check if it can filter the runs
        result = list(self.class_test._get_pipe('fake_run_fake_id_1', 1))[0]
        self.assertEqual(result.name, 'fake_run_fake_id_1')

        # check if it can get the steps from the run
        result = list(self.class_test._get_pipe('fake_run_fake_id_1', 1))
        result_details = self.class_test._get_details_from_run(result) # type: ignore
        self.assertIsInstance(result_details, Iterable)